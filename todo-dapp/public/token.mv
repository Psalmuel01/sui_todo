// Move bytecode v6
module f956684f0de72b3f14195ae80c1c6189cefaa690607a868bdf2ee742bf164b62.my_coin {
use 0000000000000000000000000000000000000000000000000000000000000001::option;
use 0000000000000000000000000000000000000000000000000000000000000002::coin;
use 0000000000000000000000000000000000000000000000000000000000000002::event;
use 0000000000000000000000000000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000000000000000000000000000002::tx_context;
use 0000000000000000000000000000000000000000000000000000000000000002::url;

struct MY_COIN has drop {
	dummy_field: bool
}

struct MintEvent has copy, drop {
	amount: u64,
	recipient: address
}

struct BurnEvent has copy, drop {
	amount: u64
}

init(Arg0: MY_COIN, Arg1: &mut TxContext) {
L2:	loc0: CoinMetadata<MY_COIN>
L3:	loc1: TreasuryCap<MY_COIN>
B0:
	0: MoveLoc[0](Arg0: MY_COIN)
	1: LdU8(2)
	2: LdConst[0](vector<u8>: "MY"..)
	3: LdConst[1](vector<u8>: "My ..)
	4: LdConst[2](vector<u8>: "My ..)
	5: Call option::none<Url>(): Option<Url>
	6: CopyLoc[1](Arg1: &mut TxContext)
	7: Call coin::create_currency<MY_COIN>(MY_COIN, u8, vector<u8>, vector<u8>, vector<u8>, Option<Url>, &mut TxContext): TreasuryCap<MY_COIN> * CoinMetadata<MY_COIN>
	8: StLoc[2](loc0: CoinMetadata<MY_COIN>)
	9: StLoc[3](loc1: TreasuryCap<MY_COIN>)
	10: MoveLoc[2](loc0: CoinMetadata<MY_COIN>)
	11: Call transfer::public_freeze_object<CoinMetadata<MY_COIN>>(CoinMetadata<MY_COIN>)
	12: MoveLoc[3](loc1: TreasuryCap<MY_COIN>)
	13: MoveLoc[1](Arg1: &mut TxContext)
	14: FreezeRef
	15: Call tx_context::sender(&TxContext): address
	16: Call transfer::public_transfer<TreasuryCap<MY_COIN>>(TreasuryCap<MY_COIN>, address)
	17: Ret
}

entry public mint(Arg0: &mut TreasuryCap<MY_COIN>, Arg1: u64, Arg2: address, Arg3: &mut TxContext) {
L4:	loc0: Coin<MY_COIN>
B0:
	0: MoveLoc[0](Arg0: &mut TreasuryCap<MY_COIN>)
	1: CopyLoc[1](Arg1: u64)
	2: MoveLoc[3](Arg3: &mut TxContext)
	3: Call coin::mint<MY_COIN>(&mut TreasuryCap<MY_COIN>, u64, &mut TxContext): Coin<MY_COIN>
	4: StLoc[4](loc0: Coin<MY_COIN>)
	5: MoveLoc[1](Arg1: u64)
	6: CopyLoc[2](Arg2: address)
	7: Pack[1](MintEvent)
	8: Call event::emit<MintEvent>(MintEvent)
	9: MoveLoc[4](loc0: Coin<MY_COIN>)
	10: MoveLoc[2](Arg2: address)
	11: Call transfer::public_transfer<Coin<MY_COIN>>(Coin<MY_COIN>, address)
	12: Ret
}

entry public burn(Arg0: &mut TreasuryCap<MY_COIN>, Arg1: Coin<MY_COIN>) {
L2:	loc0: u64
B0:
	0: ImmBorrowLoc[1](Arg1: Coin<MY_COIN>)
	1: Call coin::value<MY_COIN>(&Coin<MY_COIN>): u64
	2: StLoc[2](loc0: u64)
	3: MoveLoc[0](Arg0: &mut TreasuryCap<MY_COIN>)
	4: MoveLoc[1](Arg1: Coin<MY_COIN>)
	5: Call coin::burn<MY_COIN>(&mut TreasuryCap<MY_COIN>, Coin<MY_COIN>): u64
	6: Pop
	7: MoveLoc[2](loc0: u64)
	8: Pack[2](BurnEvent)
	9: Call event::emit<BurnEvent>(BurnEvent)
	10: Ret
}

Constants [
	0 => vector<u8>: "MY" // interpreted as UTF8 string
	1 => vector<u8>: "My Coin" // interpreted as UTF8 string
	2 => vector<u8>: "My coi description" // interpreted as UTF8 string
]
}
